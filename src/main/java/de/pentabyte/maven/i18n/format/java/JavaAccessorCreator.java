/**
 * 
 */
package de.pentabyte.maven.i18n.format.java;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.lang.model.SourceVersion;

import org.apache.commons.lang3.StringUtils;
import org.apache.maven.plugin.logging.Log;

import de.pentabyte.maven.i18n.format.java.IndentedFileWriter.CurlyBracketWriter;
import de.pentabyte.tools.i18n.core.EntryNode;
import de.pentabyte.tools.i18n.core.JavaAccessor;
import de.pentabyte.tools.i18n.core.Table;

/**
 * Creates a plain Java file with accessor methods for all translation keys.
 * Will create a method param for each MessagePattern placeholder. (e.g: {0},
 * {1})
 * 
 * @author Michael HÃ¶reth
 */
public class JavaAccessorCreator {
	private final Table table;
	private final String keySeparator;
	private final File targetDir;
	private final String messagesBaseName;

	public JavaAccessorCreator(Table table, String keySeparator, File targetDir, String messagesBaseName) {
		this.table = table;
		this.keySeparator = keySeparator;
		this.targetDir = targetDir;
		this.messagesBaseName = messagesBaseName;
	}

	/**
	 * Create a java class to access the language files.
	 * 
	 * @param log
	 * 
	 */
	public void write(Log log, JavaAccessor accessor) throws IOException {
		File accessorFile = new File(targetDir,
				accessor.getPackageName().replace('.', '/') + "/" + accessor.getClassName() + ".java");

		log.info("NOW creating JAVA accessor in targetDir: " + accessorFile);

		accessorFile.getParentFile().mkdirs();

		String fileComment = "AUTO-GENERATED from schema file with i18n-maven-plugin.\n"
				+ "Please do not edit this file manually!";

		IndentedFileWriter writer = new IndentedFileWriter(accessorFile);
		writer.writeLine("package " + accessor.getPackageName() + ";");
		writer.emptyLine();
		writer.writeLine("import java.text.MessageFormat;");
		writer.writeLine("import java.util.Locale;");
		writer.writeLine("import java.util.ResourceBundle;");
		writer.emptyLine();

		writer.writeComment(fileComment);

		CurlyBracketWriter classWriter = writer.createCurlyBracketWriter(null,
				"public class " + accessor.getClassName());
		classWriter.writeLine("private static String BASE_NAME = \"" + messagesBaseName + "\";");

		for (Entry<String, EntryNode> entry : table.createHierarchy(keySeparator).entrySet()) {
			writeEntry(writer, accessor, entry, "");
		}

		classWriter.writeLine("public static String translate(Locale locale, String key, Object... params) {");
		classWriter.writeLine("	ResourceBundle bundle = ResourceBundle.getBundle(BASE_NAME, locale);");
		classWriter.writeLine("	String pattern = bundle.getString(key);");
		classWriter.writeLine("	return (new MessageFormat(pattern, locale)).format(params);");
		classWriter.writeLine("}");

		classWriter.close();

		writer.close();
	}

	/**
	 * @param writer
	 * @param entry
	 * @throws IOException
	 */
	private void writeEntry(IndentedFileWriter writer, JavaAccessor accessor, Entry<String, EntryNode> entry,
			String prefix) throws IOException {
		writeMethod(writer, accessor, entry, prefix);

		if (entry.getValue().getNodes().size() > 0) {
			CurlyBracketWriter classWriter = writer.createCurlyBracketWriter(entry.getValue().getDescription(),
					"public static class " + escapeClassName(entry.getKey()));

			String newPrefix = prefix + entry.getKey() + ".";

			for (Entry<String, EntryNode> e : entry.getValue().getNodes().entrySet()) {
				writeEntry(writer, accessor, e, newPrefix);
			}

			classWriter.close();
		}
	}

	static Pattern PLACEHOLDER = Pattern.compile("\\{(\\d+)(,[^\\}]+)?\\}");

	/**
	 * @param writer
	 * @param entry
	 * @throws IOException
	 */
	private void writeMethod(IndentedFileWriter writer, JavaAccessor accessor, Entry<String, EntryNode> entry,
			String prefix) throws IOException {
		Map<String, String> textMap = entry.getValue().getTextMap();
		if (textMap.size() > 0) {
			String key = entry.getKey();

			String argsWithType;
			String args;

			Integer max = null;

			for (String text : entry.getValue().getTextMap().values()) {
				Matcher matcher = PLACEHOLDER.matcher(text);
				while (matcher.find()) {
					int candidate = Integer.parseInt(matcher.group(1));
					if (max == null || max < candidate)
						max = candidate;
				}
			}

			if (max == null) {
				argsWithType = "";
				args = "";
			} else {
				List<String> list1 = new ArrayList<>();
				List<String> list2 = new ArrayList<>();
				for (int i = 0; i <= max; i++) {
					list1.add("param" + i);
					list2.add("Object param" + i);
				}
				argsWithType = ", " + StringUtils.join(list2, ", ");
				args = ", " + StringUtils.join(list1, ", ");
			}

			String comment = "";
			if (StringUtils.isNotEmpty(entry.getValue().getDescription())) {
				comment = entry.getValue().getDescription() + "\n\n";
			}
			comment += "Example: \"" + entry.getValue().getTextMap().entrySet().iterator().next().getValue() + "\"";

			writer.writeComment(comment);
			writer.writeLine("public static final String " + escapeIdentifier(key) + "$ = \"" + prefix + key + "\";");

			CurlyBracketWriter methodWriter = writer.createCurlyBracketWriter(comment,
					"public static String " + escapeMethodName(key) + "$(Locale locale" + argsWithType + ")");
			methodWriter.writeLine("return " + escapeClassName(accessor.getClassName()) + ".translate(locale, "
					+ escapeIdentifier(key) + "$" + args + ");");
			methodWriter.close();
		}
	}

	/**
	 * @param key
	 * @return
	 */
	private String escapeIdentifier(String identifier) {
		if (!SourceVersion.isName(identifier))
			throw new RuntimeException("[" + identifier + "] is no valid identifier.");
		return identifier;
	}

	/**
	 * @param key
	 * @return
	 */
	private String escapeMethodName(String name) {
		if (!SourceVersion.isName(name))
			throw new RuntimeException("[" + name + "] is no valid method name.");
		return name;
	}

	/**
	 * @param key
	 * @return
	 */
	private String escapeClassName(String key) {
		if (!SourceVersion.isName(key))
			throw new RuntimeException("[" + key + "] is no valid class name.");
		return key;
	}

}
